<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>Robot Control UI with WebRTC (No-Trickle ICE)</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #f0f0f0;
      touch-action: none;
      user-select: none;
      font-family: sans-serif;
    }
    #gameArea {
      position: relative;
      width: 100vw;
      height: 100vh;
    }
    #infoPanel {
      position: absolute;
      top: 2vmin;
      left: 2vmin;
      background: rgba(255, 255, 255, 0.85);
      padding: 1.5vmin 2vmin;
      border-radius: 1vmin;
      box-shadow: 0 0.5vmin 1.5vmin rgba(0, 0, 0, 0.2);
      z-index: 10;
      font-size: 2.5vmin;
    }
    #infoPanel p {
      margin: 1vmin 0;
    }
    #robotSelector {
      position: absolute;
      top: 2vmin;
      right: 2vmin;
      z-index: 10;
      text-align: right;
      font-size: 2.5vmin;
    }
    #toggleSelector {
      background: #007bff;
      color: white;
      border: none;
      padding: 1.5vmin 2vmin;
      border-radius: 1vmin;
      cursor: pointer;
    }
    #selectorOptions {
      display: none;
      margin-top: 1vmin;
      background: rgba(255, 255, 255, 0.9);
      padding: 2vmin;
      border-radius: 1vmin;
      box-shadow: 0 0.5vmin 1.5vmin rgba(0, 0, 0, 0.2);
      text-align: left;
    }
    #selectorOptions label {
      display: block;
      margin-bottom: 1.5vmin;
      cursor: pointer;
    }
    #cameraFeed {
      position: absolute;
      top: 15vh;
      left: 20vw;
      width: 50vw;
      height: 70vh;
      border: 0.5vmin dashed #666;
      border-radius: 1vmin;
      background: #000;
      z-index: 5;
    }
    #pos_map{
      position: absolute;
      top: 15vh;
      left: 72vw;
      width: 21vw;
      height: 38vh;
      border: 0.5vmin dashed #666;
      border-radius: 1vmin;
      background: #000;
      z-index: 5;
    }
    #point_map{
      position: absolute;
      top: 57vh;
      left: 72vw;
      width: 21vw;
      height: 28vh;
      border: 0.5vmin dashed #666;
      border-radius: 1vmin;
      background: #000;
      z-index: 5;
    }
    #cameraFeed video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    #controls {
      position: absolute;
      bottom: 5vmin;
      left: 5vmin;
      display: grid;
      grid-template-areas: ". up ." "left . right" ". down .";
      grid-template-columns: 1fr 1fr 1fr;
      grid-template-rows: 1fr 1fr 1fr;
      gap: 1vmin;
      z-index: 10;
    }
    .ctrl-btn {
      width: 8vmin;
      height: 8vmin;
      border-radius: 50%;
      background: #007bff;
      color: white;
      font-size: 4vmin;
      border: none;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      touch-action: none;
      cursor: pointer;
    }
    #btnForward { grid-area: up; }
    #btnBackward { grid-area: down; }
    #btnLeft { grid-area: left; }
    #btnRight { grid-area: right; }
    .rotate-90, .rotate-270 { display: inline-block; }
    .rotate-90 { transform: rotate(90deg); }
    .rotate-270 { transform: rotate(270deg); }
  </style>
</head>
<body>
  <div id="gameArea">
    <div id="infoPanel">
      <p>Battery: <span class="value-display" id="battery">92%</span></p>
      <p>PID â†’ P: <span class="value-display" id="pidP">0.25</span>, 
         I: <span class="value-display" id="pidI">0.05</span>, 
         D: <span class="value-display" id="pidD">0.12</span></p>
      <p>Depth measured: <span class="value-display" id="depthValue">1.25m</span></p>
    </div>

    <div id="robotSelector">
      <button id="toggleSelector">Robot 1 (online) â–¾</button>
      <div id="selectorOptions">
        <label><input type="radio" name="robot" value="1" checked> Robot 1 (<span id="status1">online</span>)</label>
        <label><input type="radio" name="robot" value="2"> Robot 2 (<span id="status2">offline</span>)</label>
      </div>
    </div>

    <div id="cameraFeed">
      <video id="videoStream" autoplay playsinline></video>
      <canvas id="cameraOverlay"></canvas>
    </div>

    <div id="pos_map">
      <!-- Canvas for 2D map will be created here -->
    </div>

    <div id="point_map">
      <canvas id="pointCloud"></canvas>
    </div>

    <div id="controls">
      <button class="ctrl-btn" id="btnForward">â–²</button>
      <button class="ctrl-btn" id="btnLeft"><span class="rotate-90">â†¶</span></button>
      <button class="ctrl-btn" id="btnRight"><span class="rotate-270">â†·</span></button>
      <button class="ctrl-btn" id="btnBackward">â–¼</button>
    </div>
    
    <div id="coordinateDisplay"></div>
  </div>

    <script>
    let sensorData = {}; 

    const SIGNALING_BASE = `http://${window.location.hostname}:8000`;
    const API_BASE       = "http://35.177.215.40:8001";  
    let pc = null;
    let dataChannel = null;
    let latestBatteryPct = 0;           
    let latestMode       = "MANUAL";  
    async function logToDatabase(action) {
      if (latestBatteryPct === 0 || action === "stop") return;
      try {
        const resp = await fetch(`${API_BASE}/log`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            battery: latestBatteryPct,
            mode:    latestMode,
            action:  action.toUpperCase()
          }),
        });
        if (!resp.ok) throw new Error(`${resp.status} ${resp.statusText}`);
        console.log("ğŸ“ Logged to DB:", action, latestBatteryPct, latestMode);
      } catch (err) {
        console.warn("DB log failed:", err.message);
      }
    }  

    
    
 function sendControl(direction) {
      if (dataChannel && dataChannel.readyState === "open") {
        dataChannel.send(JSON.stringify({ direction }));
        logToDatabase(direction);
      }
    }
function handleTelemetry(json) {
  try {
    const t = JSON.parse(json);
    // battery
    if (typeof t.battery === "number") {
      latestBatteryPct = t.battery;
      document.getElementById("battery").textContent = t.battery + "%";
    }
    // optional mode coming from Pi
    if (t.mode) latestMode = t.mode.toUpperCase();
    // pid display
    if (t.pidP != null) document.getElementById("pidP").textContent = t.pidP;
    if (t.pidI != null) document.getElementById("pidI").textContent = t.pidI;
    if (t.pidD != null) document.getElementById("pidD").textContent = t.pidD;
  } catch (e) {
    console.warn("Bad telemetry JSON:", e);
  }
}

/* -------------------- 6.  WEBRTC SET-UP ----------------------- */
/* unchanged except one line that calls handleTelemetry */
async function startWebRTC() {
  pc = new RTCPeerConnection({ iceServers:[{urls:"stun:stun.l.google.com:19302"}]});
  pc.addTransceiver("video",{direction:"recvonly"});
  dataChannel = pc.createDataChannel("control",{ordered:true});

  dataChannel.onopen  = () => console.log("â–¶ï¸ DataChannel OPEN");
  dataChannel.onclose = () => console.log("ğŸ”Œ DataChannel closed");
  dataChannel.onmessage = e => handleTelemetry(e.data);

  /* â€¦ everything else exactly as before â€¦ */
}

    // 2) Set up WebRTC / DataChannel
    async function startWebRTC() {
      pc = new RTCPeerConnection({
        iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
      });

      pc.addTransceiver("video", { direction: "recvonly" });

      dataChannel = pc.createDataChannel("control", { ordered: true });
      dataChannel.onopen = () => {
        console.log("â–¶ï¸ DataChannel is now OPEN");
        // Mark selected robot as online
        const sel = document.querySelector('input[name="robot"]:checked');
        sel.parentNode.querySelector('span').textContent = "online";
      };
      
       window.addEventListener('load', () => {
      startWebRTC().catch(e => console.error("startWebRTC() threw:", e));
      // â€¦ initMap, simulateRobot, robot selector, etc. â€¦
    });

    // key controls


      dataChannel.onmessage = (evt) => {
        console.log("ğŸ›°ï¸ Telemetry from Pi:", evt.data);
        try {
          const telemetry = JSON.parse(evt.data);
          document.getElementById("battery").textContent = telemetry.battery + "%";
          document.getElementById("pidP").textContent    = telemetry.pidP;
          document.getElementById("pidI").textContent    = telemetry.pidI;
          document.getElementById("pidD").textContent    = telemetry.pidD;
        } catch (e) {
          console.warn("Invalid telemetry JSON:", e);
        }
      };
      dataChannel.onclose = () => {
        console.log("ğŸ”Œ DataChannel closed");
        const sel = document.querySelector('input[name="robot"]:checked');
        sel.parentNode.querySelector('span').textContent = "offline";
      };

      pc.ontrack = (ev) => {
        const video = document.getElementById("videoStream");
        if (!video.srcObject) {
          video.srcObject = ev.streams[0];
        }
      };

      // 2a) Create an SDP offer and wait for ICE gathering
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);

      await new Promise(resolve => {
        if (pc.iceGatheringState === "complete") {
          resolve();
        } else {
          pc.onicegatheringstatechange = () => {
            if (pc.iceGatheringState === "complete") {
              pc.onicegatheringstatechange = null;
              resolve();
            }
          };
        }
      });

      // 2b) POST the complete SDP to /offer on the Pi
      let resp;
      try {
        resp = await fetch(`${SIGNALING_BASE}/offer`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            peer_id: "browser1",
            type:    pc.localDescription.type,
            sdp:     pc.localDescription.sdp
          })
        });
      } catch (networkError) {
        console.error("Network error when calling /offer:", networkError);
        return;
      }

      if (!resp.ok) {
        const text = await resp.text();
        console.error("Offer failed", resp.status, text);
        return;
      }

      let answer;
      try {
        answer = await resp.json();
      } catch (jsonError) {
        console.error("Failed to parse JSON from /offer:", jsonError);
        return;
      }

      await pc.setRemoteDescription(new RTCSessionDescription(answer));
      console.log("WebRTC connection established");
    }

    fetch('/data/sensor_output.csv')
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.text();
        })
        .then(csvText => {
            sensorData = parseCSV(csvText);
        })
        .catch(error => console.error(error));

    function parseCSV(csvText) {
        const lines = csvText.trim().split('\n');
        if (lines.length < 2) return []; 

        const headers = lines[0].split(',').map(h => h.trim());

        return lines.slice(1).map(line => {
            const values = line.split(','); 
            return headers.reduce((obj, header, index) => {
                const value = values[index] ? values[index].trim() : '';
                obj[header] = isNaN(value) ? value : parseFloat(value);
                return obj;
            }, {});
        });
    }
    
    let currentDataIndex = 0;
    const mapCanvas = document.createElement('canvas');
    const posMap = document.getElementById('pos_map');

    const mapCtx = mapCanvas.getContext('2d');
    posMap.appendChild(mapCanvas);

    // 5m x 5m åœ°å›¾ï¼Œ250x250 åƒç´  (æ¯ä¸ªåƒç´  0.02m)
    const mapSize = 5; // 5 meters
    const mapPixels = 250; // 250 pixels
    const pixelSize = mapSize / mapPixels; // 0.02m per pixel

    // å›ºå®šæ˜¾ç¤ºçª—å£ä¸º 2m x 2m
    const displaySize = 2; // 2 meters

    function setupCanvas() {
      // è®¡ç®—æ˜¾ç¤ºçª—å£çš„åƒç´ å°ºå¯¸ (2m / 0.02m = 100 pixels)
      const displayPixels = Math.round(displaySize / pixelSize);
      mapCanvas.width = posMap.clientWidth;
      mapCanvas.height = posMap.clientHeight;
    }

    const mapState = {
      exploredPaths: [],
      detectedSurfaces: [],
      robotPath: [],
      robotPosition: { x: mapSize/2, y: mapSize/2 }, // åˆå§‹åœ¨ä¸­å¿ƒ (2.5m, 2.5m)
      robotAngle: 0,
      robotRadius: 0.08 // 8cm radius
    };

    // åˆ›å»ºåœ°å›¾æ•°æ®æ•°ç»„ (250x250)
    let mapData = new Array(mapPixels);
    for (let i = 0; i < mapPixels; i++) {
      mapData[i] = new Array(mapPixels).fill(0); // 0è¡¨ç¤ºæœªæ¢ç´¢
    }

    function initMap() {
      setupCanvas();
      drawMap();
      mapCanvas.addEventListener('click', handleMapClick);
      window.addEventListener('resize', () => {
        setupCanvas();
        drawMap();
      });
    }

    function drawMap() {
      const width = mapCanvas.width;
      const height = mapCanvas.height;
      
      // è®¡ç®—æ˜¾ç¤ºçª—å£çš„è¾¹ç•Œ (ä»¥æœºå™¨äººä½ç½®ä¸ºä¸­å¿ƒ)
      const minX = Math.max(0, Math.floor((mapState.robotPosition.x - displaySize/2) / pixelSize));
      const maxX = Math.min(mapPixels-1, Math.ceil((mapState.robotPosition.x + displaySize/2) / pixelSize));
      const minY = Math.max(0, Math.floor((mapState.robotPosition.y - displaySize/2) / pixelSize));
      const maxY = Math.min(mapPixels-1, Math.ceil((mapState.robotPosition.y + displaySize/2) / pixelSize));
      
      // è®¡ç®—æ˜¾ç¤ºåç§» (ç¡®ä¿æœºå™¨äººå§‹ç»ˆåœ¨ä¸­å¿ƒ)
      const offsetX = (width/2) - (mapState.robotPosition.x / pixelSize - minX);
      const offsetY = (height/2) - (mapState.robotPosition.y / pixelSize - minY);
      
      // ç»˜åˆ¶åœ°å›¾
      mapCtx.fillStyle = '#d3d3d3';
      mapCtx.fillRect(0, 0, width, height);
      
      // ç»˜åˆ¶æ¢ç´¢åŒºåŸŸ (ä»mapDataè¯»å–)
      for (let y = minY; y <= maxY; y++) {
        for (let x = minX; x <= maxX; x++) {
          if (mapData[y][x] === 1) { // æ¢ç´¢åŒºåŸŸ
            const screenX = (x - minX) + offsetX;
            const screenY = (y - minY) + offsetY;
            mapCtx.fillStyle = 'rgba(127, 255, 212, 0.4)';
            mapCtx.fillRect(screenX, screenY, 1, 1);
          } else if (mapData[y][x] === 2) { // éšœç¢ç‰©è¡¨é¢
            const screenX = (x - minX) + offsetX;
            const screenY = (y - minY) + offsetY;
            mapCtx.fillStyle = '#0000ff';
            mapCtx.fillRect(screenX, screenY, 1, 1);
          }
        }
      }
      
      // ç»˜åˆ¶æœºå™¨äººè·¯å¾„ (ä»robotPathè¯»å–)
      mapCtx.strokeStyle = 'rgba(127, 255, 212, 0.7)';
      mapCtx.lineWidth = 2;
      mapCtx.beginPath();
      mapState.robotPath.forEach((point, index) => {
        const x = (point.x / pixelSize - minX) + offsetX;
        const y = (point.y / pixelSize - minY) + offsetY;
        if (index === 0) {
          mapCtx.moveTo(x, y);
        } else {
          mapCtx.lineTo(x, y);
        }
      });
      mapCtx.stroke();
      
      // ç»˜åˆ¶æœºå™¨äºº (å§‹ç»ˆåœ¨ä¸­å¿ƒ)
      const robotX = width/2;
      const robotY = height/2;
      const robotRadiusPixels = mapState.robotRadius / pixelSize;
      mapCtx.fillStyle = '#ff0000';
      mapCtx.beginPath();
      mapCtx.arc(robotX, robotY, robotRadiusPixels, 0, Math.PI * 2);
      mapCtx.fill();
    }

    function simulateRobot() {
      const depthValue = document.getElementById('depthValue');
      const data = sensorData[currentDataIndex];
      console.log(data);
      depthValue.textContent = `${data.depth.toFixed(2)}m`;
      mapState.robotAngle = data.orient_y.toFixed(2);

      mapState.robotPosition.x += data.d_pos_x;
      mapState.robotPosition.y += data.d_pos_y;
      
      // é™åˆ¶æœºå™¨äººä½ç½®åœ¨åœ°å›¾èŒƒå›´å†…
      mapState.robotPosition.x = Math.max(mapState.robotRadius, Math.min(mapSize - mapState.robotRadius, mapState.robotPosition.x));
      mapState.robotPosition.y = Math.max(mapState.robotRadius, Math.min(mapSize - mapState.robotRadius, mapState.robotPosition.y));
      
      mapState.robotPath.push({
        x: mapState.robotPosition.x,
        y: mapState.robotPosition.y
      });
      
      if (mapState.robotPath.length > 300) {
        mapState.robotPath.shift();
      }
      
      // æ›´æ–°æ¢ç´¢åŒºåŸŸ (æ ‡è®°ä¸º1)
      const robotX = Math.floor(mapState.robotPosition.x / pixelSize);
      const robotY = Math.floor(mapState.robotPosition.y / pixelSize);
      for (let dy = -5; dy <= 5; dy++) {
        for (let dx = -5; dx <= 5; dx++) {
          const x = robotX + dx;
          const y = robotY + dy;
          if (x >= 0 && x < mapPixels && y >= 0 && y < mapPixels) {
            mapData[y][x] = 1;
          }
        }
      }
      
      // æ›´æ–°éšœç¢ç‰©è¡¨é¢ (æ ‡è®°ä¸º2)
      const rayLength = data.depth;
      const angleRad = mapState.robotAngle * Math.PI / 180;
      const dirX = Math.sin(angleRad);
      const dirY = -Math.cos(angleRad);
      
      const surfaceX = Math.floor((mapState.robotPosition.x + dirX * rayLength) / pixelSize);
      const surfaceY = Math.floor((mapState.robotPosition.y + dirY * rayLength) / pixelSize);
      
      if (surfaceX >= 0 && surfaceX < mapPixels && surfaceY >= 0 && surfaceY < mapPixels) {
        mapData[surfaceY][surfaceX] = 2;
      }
      
      // é‡ç»˜åœ°å›¾
      drawMap();
      
      // æ›´æ–°æ•°æ®ç´¢å¼•
      currentDataIndex = (currentDataIndex + 1) % sensorData.length;
    }

    function handleMapClick(event) {
      const rect = mapCanvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      
      const width = mapCanvas.width;
      const height = mapCanvas.height;
      
      // è®¡ç®—æ˜¾ç¤ºçª—å£çš„è¾¹ç•Œ
      const minX = Math.max(0, Math.floor((mapState.robotPosition.x - displaySize/2) / pixelSize));
      const minY = Math.max(0, Math.floor((mapState.robotPosition.y - displaySize/2) / pixelSize));
      
      // è®¡ç®—ç‚¹å‡»çš„å®é™…åæ ‡
      const offsetX = (width/2) - (mapState.robotPosition.x / pixelSize - minX);
      const offsetY = (height/2) - (mapState.robotPosition.y / pixelSize - minY);
      
      const realX = (x - offsetX + minX) * pixelSize;
      const realY = (y - offsetY + minY) * pixelSize;
      
      const mmX = Math.round(realX * 1000);
      const mmY = Math.round(realY * 1000);

      const display = document.getElementById('coordinateDisplay');
      display.textContent = `Clicked at: X=${mmX}mm, Y=${mmY}mm`;
      display.style.display = 'block';
      
      setTimeout(() => {display.style.display = 'none';}, 3000);
      
      mapCtx.fillStyle = '#ff9900';
      mapCtx.beginPath();
      mapCtx.arc(x, y, 5, 0, Math.PI * 2);
      mapCtx.fill();
    }
        
    // åˆå§‹åŒ–
    window.addEventListener('load', () => {
      startWebRTC().catch(e => console.error("startWebRTC() threw:", e));
      initMap();
      
      // å¼€å§‹æ¨¡æ‹Ÿ
      setInterval(simulateRobot, 50); // 20Hzæ›´æ–°
      
      // æœºå™¨äººé€‰æ‹©å™¨åˆ‡æ¢
      document.getElementById('toggleSelector').addEventListener('click', () => {
        const options = document.getElementById('selectorOptions');
        options.style.display = options.style.display === 'block' ? 'none' : 'block';
      });
    });

    // 3) Attach keydown/keyup listeners
    console.log("Attaching keydown/keyup listeners");
    document.addEventListener('keydown', e => {
      switch (e.key.toLowerCase()) {
        case 'w': sendControl("forward");  break;
        case 's': sendControl("backward"); break;
        case 'a': sendControl("left");     break;
        case 'd': sendControl("right");    break;
      }
    });
    document.addEventListener('keyup', e => {
      switch (e.key.toLowerCase()) {
        case 'w':
        case 's':
        case 'a':
        case 'd':
          sendControl("stop");
          break;
      }
    });

    // 4) Attach on-screen button listeners 
    function bindBtn(id, dirName) {
      const btn = document.getElementById(id);
      console.log(`Binding pointerdown for ${id} â†’ ${dirName}`);
      btn.addEventListener('pointerdown', () => {
        console.log(`${id} pointerdown â†’ sendControl("${dirName}")`);
        sendControl(dirName);
      });
      btn.addEventListener('pointerup', () => {
        console.log(`${id} pointerup â†’ sendControl("stop")`);
        sendControl("stop");
      });
      btn.addEventListener('pointerleave', () => {
        console.log(`${id} pointerleave â†’ sendControl("stop")`);
        sendControl("stop");
      });
    }
    bindBtn('btnForward',  'forward');
    bindBtn('btnBackward', 'backward');
    bindBtn('btnLeft',     'left');
    bindBtn('btnRight',    'right');

    // 5) Robot selector dropdown logic
    const toggleBtn = document.getElementById('toggleSelector');
    const opts      = document.getElementById('selectorOptions');
    function updateToggle() {
      const sel = document.querySelector('input[name="robot"]:checked');
      toggleBtn.textContent = sel.parentNode.textContent.trim() + ' â–¾';
    }
    toggleBtn.addEventListener('click', () => {
      opts.style.display = opts.style.display === 'block' ? 'none' : 'block';
    });
    document.querySelectorAll('input[name="robot"]').forEach(r => {
      r.addEventListener('change', () => updateToggle());
    });
    updateToggle();
  </script>
</body>
</html>