<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" /><meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>Robot Control UI with WebRTC (No‐Trickle ICE)</title>
  <style>
    html, body { margin:0; padding:0; width:100%; height:100%; overflow:hidden; background:#f0f0f0; touch-action:none; user-select:none; font-family:sans-serif; }
    #gameArea { position:relative; width:100vw; height:100vh; }
    #infoPanel { position:absolute; top:2vmin; left:2vmin; background:rgba(255,255,255,0.85); padding:1.5vmin 2vmin; border-radius:1vmin; box-shadow:0 0.5vmin 1.5vmin rgba(0,0,0,0.2); z-index:10; font-size:2.5vmin; }
    #infoPanel p { margin:1vmin 0; }
    #robotSelector { position:absolute; top:2vmin; right:2vmin; z-index:10; text-align:right; font-size:2.5vmin; }
    #toggleSelector { background:#007bff; color:white; border:none; padding:1.5vmin 2vmin; border-radius:1vmin; cursor:pointer; }
    #selectorOptions { display:none; margin-top:1vmin; background:rgba(255,255,255,0.9); padding:2vmin; border-radius:1vmin; box-shadow:0 0.5vmin 1.5vmin rgba(0,0,0,0.2); text-align:left; }
    #selectorOptions label { display:block; margin-bottom:1.5vmin; cursor:pointer; }
    #cameraFeed { position:absolute; top:20vh; left:20vw; width:60vw; height:60vh; border:0.5vmin dashed #666; border-radius:1vmin; background:#000; z-index:5; }
    #cameraFeed video { width:100%; height:100%; object-fit:cover; }
    #player { position:absolute; width:10vmin; height:10vmin; background:#007bff; top:calc(50% - 5vmin); left:calc(50% - 5vmin); transform-origin:center; z-index:6; }
    #controls { position:absolute; bottom:5vmin; left:5vmin; display:grid; grid-template-areas:". up ." "left . right" ". down ."; grid-template-columns:1fr 1fr 1fr; grid-template-rows:1fr 1fr 1fr; gap:1vmin; z-index:10; }
    .ctrl-btn { width:8vmin; height:8vmin; border-radius:50%; background:#007bff; color:white; font-size:4vmin; border:none; display:flex; align-items:center; justify-content:center; user-select:none; touch-action:none; cursor:pointer; }
    #btnForward { grid-area: up; } #btnBackward { grid-area: down; } #btnLeft { grid-area: left; } #btnRight { grid-area: right; }
    .rotate-90, .rotate-270 { display:inline-block; }
    .rotate-90 { transform: rotate(90deg); } .rotate-270 { transform: rotate(270deg); }
  </style>
</head>
<body>
  <div id="gameArea">
    <div id="infoPanel">
      <p>Battery: <span id="battery">—</span></p>
      <p>PID → P: <span id="pidP">—</span>, I: <span id="pidI">—</span>, D: <span id="pidD">—</span></p>
    </div>

    <div id="robotSelector">
      <button id="toggleSelector">Robot 1 (offline) ▾</button>
      <div id="selectorOptions">
        <label><input type="radio" name="robot" value="1" checked> Robot 1 (<span id="status1">offline</span>)</label>
        <label><input type="radio" name="robot" value="2"> Robot 2 (<span id="status2">offline</span>)</label>
      </div>
    </div>

    <div id="cameraFeed">
      <video id="videoStream" autoplay playsinline></video>
    </div>

    <div id="player"></div>

    <div id="controls">
      <button class="ctrl-btn" id="btnForward">▲</button>
      <button class="ctrl-btn" id="btnLeft"><span class="rotate-90">↶</span></button>
      <button class="ctrl-btn" id="btnRight"><span class="rotate-270">↷</span></button>
      <button class="ctrl-btn" id="btnBackward">▼</button>
    </div>
  </div>

  <script>
  // ───────────── Configuration ─────────────────────────────────────────────────
  // Fetch and signal back to whatever host served this page (the Pi).
  // We bind to port 8000 (your pi_peer.py HTTP server).
  const SIGNALING_BASE = `http://${window.location.hostname}:8000`;

  // You can remove any `PI_IP` or `SIGNALING_URL` definitions—just use SIGNALING_BASE.
  // ────────────────────────────────────────────────────────────────────────────────

  let pc = null;
  let dataChannel = null;

  async function startWebRTC() {
    // 1) Create the RTCPeerConnection, DataChannel, etc.
    pc = new RTCPeerConnection({
      iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
    });
    dataChannel = pc.createDataChannel("control", { ordered: true });
    dataChannel.onopen = () => { };
    dataChannel.onmessage = (evt) => { };
    dataChannel.onclose = () => { };

    pc.ontrack = (ev) => { };

    // 2) Create an SDP offer and wait for ICE to finish gathering:
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    await new Promise(resolve => {
      if (pc.iceGatheringState === "complete") {
        resolve();
      } else {
        pc.onicegatheringstatechange = () => {
          if (pc.iceGatheringState === "complete") {
            pc.onicegatheringstatechange = null;
            resolve();
          }
        };
      }
    });

    // 3) Post the *complete* SDP to /offer on port 8000 of the same host:
    let resp;
    try {
      resp = await fetch(`${SIGNALING_BASE}/offer`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          peer_id: "browser1",
          type:    pc.localDescription.type,
          sdp:     pc.localDescription.sdp
        })
      });
    } catch (networkError) {
      console.error("Network error when calling /offer:", networkError);
      return;
    }

    if (!resp.ok) {
      const text = await resp.text();
      console.error("Offer failed", resp.status, text);
      return;
    }

    let answer;
    try {
      answer = await resp.json();
    } catch (jsonError) {
      console.error("Failed to parse JSON from /offer:", jsonError);
      return;
    }

    await pc.setRemoteDescription(new RTCSessionDescription(answer));
    console.log("WebRTC connection established");
  }

  window.addEventListener("load", () => {
    startWebRTC().catch(e => console.error("startWebRTC() threw:", e));
  });

    // ─── Robot selector & control code (unchanged from your last working UI) ────
    const toggleBtn = document.getElementById('toggleSelector');
    const opts      = document.getElementById('selectorOptions');
    function updateToggle() {
      const sel = document.querySelector('input[name="robot"]:checked');
      toggleBtn.textContent = sel.parentNode.textContent.trim() + ' ▾';
    }
    toggleBtn.addEventListener('click', () => {
      opts.style.display = opts.style.display === 'block' ? 'none' : 'block';
    });
    document.querySelectorAll('input[name="robot"]').forEach(r => {
      r.addEventListener('change', () => updateToggle());
    });
    updateToggle();

    let angle = -Math.PI/2;
    const speed = Math.min(window.innerWidth, window.innerHeight) * 0.3;
    const angularSpeed = Math.PI;
    let lastTime = performance.now();
    const keys = { up:false, down:false, left:false, right:false };
    const player = document.getElementById('player');

    function sendControl(direction) {
      if (dataChannel && dataChannel.readyState === "open") {
        const msg = {
          robotId:   document.querySelector('input[name="robot"]:checked').value,
          action:    "move",
          direction: direction,
          timestamp: new Date().toISOString()
        };
        dataChannel.send(JSON.stringify(msg));
        console.log("Sent control →", msg);
      }
    }

    document.addEventListener('keydown', e => {
      switch(e.key.toLowerCase()) {
        case 'w': if (!keys.up)   { keys.up = true;   sendControl("forward");  } break;
        case 's': if (!keys.down) { keys.down = true; sendControl("backward"); } break;
        case 'a': if (!keys.left) { keys.left = true; sendControl("left");     } break;
        case 'd': if (!keys.right){ keys.right = true;sendControl("right");    } break;
      }
    });
    document.addEventListener('keyup', e => {
      switch(e.key.toLowerCase()) {
        case 'w': keys.up = false;   sendControl("stop"); break;
        case 's': keys.down = false; sendControl("stop"); break;
        case 'a': keys.left = false; sendControl("stop"); break;
        case 'd': keys.right = false;sendControl("stop"); break;
      }
    });

    function bindBtn(id, keyName, dirName) {
      const btn = document.getElementById(id);
      btn.addEventListener('pointerdown', () => {
        keys[keyName] = true;
        sendControl(dirName);
      });
      btn.addEventListener('pointerup', () => {
        keys[keyName] = false;
        sendControl("stop");
      });
      btn.addEventListener('pointerleave', () => {
        keys[keyName] = false;
        sendControl("stop");
      });
    }
    bindBtn('btnForward',  'up',   'forward');
    bindBtn('btnBackward', 'down', 'backward');
    bindBtn('btnLeft',     'left', 'left');
    bindBtn('btnRight',    'right','right');

    function update(now) {
      const dt = (now - lastTime)/1000;
      lastTime = now;

      if (keys.left)  angle -= angularSpeed * dt;
      if (keys.right) angle += angularSpeed * dt;

      let vx = 0, vy = 0;
      if (keys.up)   { vx += Math.cos(angle)*speed; vy += Math.sin(angle)*speed; }
      if (keys.down) { vx -= Math.cos(angle)*speed; vy -= Math.sin(angle)*speed; }

      const style = getComputedStyle(player);
      let x = parseFloat(style.left), y = parseFloat(style.top);
      x = Math.min(Math.max(0, x + vx*dt), window.innerWidth  - player.clientWidth);
      y = Math.min(Math.max(0, y + vy*dt), window.innerHeight - player.clientHeight);

      player.style.left = x + 'px';
      player.style.top  = y + 'px';
      player.style.transform = `rotate(${angle}rad)`;

      requestAnimationFrame(update);
    }
    requestAnimationFrame(update);
    window.addEventListener('resize', () => location.reload());
    // ───────────────────────────────────────────────────────────────────────────────
  </script>
</body>
</html>
