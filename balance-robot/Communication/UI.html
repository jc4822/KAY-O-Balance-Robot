<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" /><meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>Robot Control UI with WebRTC (No‐Trickle ICE)</title>
  <style>
    html, body { margin:0; padding:0; width:100%; height:100%; overflow:hidden; background:#f0f0f0; touch-action:none; user-select:none; font-family:sans-serif; }
    #gameArea { position:relative; width:100vw; height:100vh; }
    #infoPanel { position:absolute; top:2vmin; left:2vmin; background:rgba(255,255,255,0.85); padding:1.5vmin 2vmin; border-radius:1vmin; box-shadow:0 0.5vmin 1.5vmin rgba(0,0,0,0.2); z-index:10; font-size:2.5vmin; }
    #infoPanel p { margin:1vmin 0; }
    #robotSelector { position:absolute; top:2vmin; right:2vmin; z-index:10; text-align:right; font-size:2.5vmin; }
    #toggleSelector { background:#007bff; color:white; border:none; padding:1.5vmin 2vmin; border-radius:1vmin; cursor:pointer; }
    #selectorOptions { display:none; margin-top:1vmin; background:rgba(255,255,255,0.9); padding:2vmin; border-radius:1vmin; box-shadow:0 0.5vmin 1.5vmin rgba(0,0,0,0.2); text-align:left; }
    #selectorOptions label { display:block; margin-bottom:1.5vmin; cursor:pointer; }
    #cameraFeed { position:absolute; top:20vh; left:20vw; width:60vw; height:60vh; border:0.5vmin dashed #666; border-radius:1vmin; background:#000; z-index:5; }
    #cameraFeed video { width:100%; height:100%; object-fit:cover; }
    #player { position:absolute; width:10vmin; height:10vmin; background:#007bff; top:calc(50% - 5vmin); left:calc(50% - 5vmin); transform-origin:center; z-index:6; }
    #controls { position:absolute; bottom:5vmin; left:5vmin; display:grid; grid-template-areas:". up ." "left . right" ". down ."; grid-template-columns:1fr 1fr 1fr; grid-template-rows:1fr 1fr 1fr; gap:1vmin; z-index:10; }
    .ctrl-btn { width:8vmin; height:8vmin; border-radius:50%; background:#007bff; color:white; font-size:4vmin; border:none; display:flex; align-items:center; justify-content:center; user-select:none; touch-action:none; cursor:pointer; }
    #btnForward { grid-area: up; } #btnBackward { grid-area: down; } #btnLeft { grid-area: left; } #btnRight { grid-area: right; }
    .rotate-90, .rotate-270 { display:inline-block; }
    .rotate-90 { transform: rotate(90deg); } .rotate-270 { transform: rotate(270deg); }
  </style>
</head>
<body>
  <div id="gameArea">
    <div id="infoPanel">
      <p>Battery: <span id="battery">—</span></p>
      <p>PID → P: <span id="pidP">—</span>, I: <span id="pidI">—</span>, D: <span id="pidD">—</span></p>
    </div>

    <div id="robotSelector">
      <button id="toggleSelector">Robot 1 (offline) ▾</button>
      <div id="selectorOptions">
        <label><input type="radio" name="robot" value="1" checked> Robot 1 (<span id="status1">offline</span>)</label>
        <label><input type="radio" name="robot" value="2"> Robot 2 (<span id="status2">offline</span>)</label>
      </div>
    </div>

    <div id="cameraFeed">
      <video id="videoStream" autoplay playsinline></video>
    </div>

    <div id="player"></div>

    <div id="controls">
      <button class="ctrl-btn" id="btnForward">▲</button>
      <button class="ctrl-btn" id="btnLeft"><span class="rotate-90">↶</span></button>
      <button class="ctrl-btn" id="btnRight"><span class="rotate-270">↷</span></button>
      <button class="ctrl-btn" id="btnBackward">▼</button>
    </div>
  </div>

  <script>
    // ─── Configuration ────────────────────────────────────────────────────────────
    const PI_IP = "192.168.178.185";   // ← put your Pi’s LAN IP here
    const SIGNALING_URL = `http://${PI_IP}:8000/offer`;
    const PEER_ID = "browser1";        // a unique ID for this browser instance
    // ─────────────────────────────────────────────────────────────────────────────

    let pc = null;
    let dataChannel = null;

    async function startWebRTC() {
      // 1a) Create RTCPeerConnection
      pc = new RTCPeerConnection({
        iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
      });

      // 1b) Create our DataChannel “control” immediately
      dataChannel = pc.createDataChannel("control", { ordered: true });
      dataChannel.onopen = () => {
        console.log("DataChannel open (browser→pi)");
        document.querySelector('input[name="robot"]:checked')
                .parentNode.querySelector('span').textContent = "online";
      };
      dataChannel.onmessage = (evt) => {
        const telemetry = JSON.parse(evt.data);
        document.getElementById("battery").textContent = telemetry.battery + "%";
        document.getElementById("pidP").textContent    = telemetry.pidP;
        document.getElementById("pidI").textContent    = telemetry.pidI;
        document.getElementById("pidD").textContent    = telemetry.pidD;
      };
      dataChannel.onclose = () => {
        console.log("DataChannel closed");
        document.querySelector('input[name="robot"]:checked')
                .parentNode.querySelector('span').textContent = "offline";
      };

      // 1c) If Pi later adds a video track in its answer, receive it here
      pc.ontrack = (ev) => {
        const video = document.getElementById("videoStream");
        if (!video.srcObject) {
          video.srcObject = ev.streams[0];
        }
      };

      // 1d) Create an “offer” but wait until ICE gathering is finished
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);

      // Wait for ICE gathering to complete (so all candidates appear in SDP)
      await new Promise(resolve => {
        if (pc.iceGatheringState === "complete") {
          resolve();
        } else {
          pc.onicegatheringstatechange = () => {
            if (pc.iceGatheringState === "complete") {
              pc.onicegatheringstatechange = null;
              resolve();
            }
          };
        }
      });

      // 1e) Now send the COMPLETE SDP (including all a=candidate lines) to the Pi
      let resp;
      try {
        resp = await fetch(SIGNALING_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            peer_id: PEER_ID,
            type:    pc.localDescription.type,
            sdp:     pc.localDescription.sdp
          })
        });
      } catch (networkErr) {
        console.error("Network error when calling /offer:", networkErr);
        return;
      }

      if (!resp.ok) {
        const text = await resp.text();
        console.error("Offer failed", resp.status, text);
        return;
      }

      // 1f) Parse the Pi’s answer SDP (which also contains all its candidates)
      let answer;
      try {
        answer = await resp.json();
      } catch (jsonErr) {
        console.error("Failed to parse JSON from /offer:", jsonErr);
        return;
      }

      // 1g) Set the remote description (the Pi’s answer, with candidates)
      await pc.setRemoteDescription(new RTCSessionDescription(answer));

      console.log("WebRTC connection established");
      // Now the DataChannel “control” is open, so UI can send JSON → Pi
    }

    // Kick off WebRTC as soon as the page loads
    window.addEventListener("load", () => {
      startWebRTC().catch(e => console.error("startWebRTC() threw:", e));
    });

    // ─── Robot selector & control code (unchanged from your last working UI) ────
    const toggleBtn = document.getElementById('toggleSelector');
    const opts      = document.getElementById('selectorOptions');
    function updateToggle() {
      const sel = document.querySelector('input[name="robot"]:checked');
      toggleBtn.textContent = sel.parentNode.textContent.trim() + ' ▾';
    }
    toggleBtn.addEventListener('click', () => {
      opts.style.display = opts.style.display === 'block' ? 'none' : 'block';
    });
    document.querySelectorAll('input[name="robot"]').forEach(r => {
      r.addEventListener('change', () => updateToggle());
    });
    updateToggle();

    let angle = -Math.PI/2;
    const speed = Math.min(window.innerWidth, window.innerHeight) * 0.3;
    const angularSpeed = Math.PI;
    let lastTime = performance.now();
    const keys = { up:false, down:false, left:false, right:false };
    const player = document.getElementById('player');

    function sendControl(direction) {
      if (dataChannel && dataChannel.readyState === "open") {
        const msg = {
          robotId:   document.querySelector('input[name="robot"]:checked').value,
          action:    "move",
          direction: direction,
          timestamp: new Date().toISOString()
        };
        dataChannel.send(JSON.stringify(msg));
        console.log("Sent control →", msg);
      }
    }

    document.addEventListener('keydown', e => {
      switch(e.key.toLowerCase()) {
        case 'w': if (!keys.up)   { keys.up = true;   sendControl("forward");  } break;
        case 's': if (!keys.down) { keys.down = true; sendControl("backward"); } break;
        case 'a': if (!keys.left) { keys.left = true; sendControl("left");     } break;
        case 'd': if (!keys.right){ keys.right = true;sendControl("right");    } break;
      }
    });
    document.addEventListener('keyup', e => {
      switch(e.key.toLowerCase()) {
        case 'w': keys.up = false;   sendControl("stop"); break;
        case 's': keys.down = false; sendControl("stop"); break;
        case 'a': keys.left = false; sendControl("stop"); break;
        case 'd': keys.right = false;sendControl("stop"); break;
      }
    });

    function bindBtn(id, keyName, dirName) {
      const btn = document.getElementById(id);
      btn.addEventListener('pointerdown', () => {
        keys[keyName] = true;
        sendControl(dirName);
      });
      btn.addEventListener('pointerup', () => {
        keys[keyName] = false;
        sendControl("stop");
      });
      btn.addEventListener('pointerleave', () => {
        keys[keyName] = false;
        sendControl("stop");
      });
    }
    bindBtn('btnForward',  'up',   'forward');
    bindBtn('btnBackward', 'down', 'backward');
    bindBtn('btnLeft',     'left', 'left');
    bindBtn('btnRight',    'right','right');

    function update(now) {
      const dt = (now - lastTime)/1000;
      lastTime = now;

      if (keys.left)  angle -= angularSpeed * dt;
      if (keys.right) angle += angularSpeed * dt;

      let vx = 0, vy = 0;
      if (keys.up)   { vx += Math.cos(angle)*speed; vy += Math.sin(angle)*speed; }
      if (keys.down) { vx -= Math.cos(angle)*speed; vy -= Math.sin(angle)*speed; }

      const style = getComputedStyle(player);
      let x = parseFloat(style.left), y = parseFloat(style.top);
      x = Math.min(Math.max(0, x + vx*dt), window.innerWidth  - player.clientWidth);
      y = Math.min(Math.max(0, y + vy*dt), window.innerHeight - player.clientHeight);

      player.style.left = x + 'px';
      player.style.top  = y + 'px';
      player.style.transform = `rotate(${angle}rad)`;

      requestAnimationFrame(update);
    }
    requestAnimationFrame(update);
    window.addEventListener('resize', () => location.reload());
    // ───────────────────────────────────────────────────────────────────────────────
  </script>
</body>
</html>
