<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>Robot Control UI</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #f0f0f0;
      touch-action: none;
      user-select: none;
      font-family: sans-serif;
    }
    #gameArea {
      position: relative;
      width: 100vw;
      height: 100vh;
    }
    #infoPanel {
      position: absolute;
      top: 2vmin;
      left: 2vmin;
      background: rgba(255, 255, 255, 0.85);
      padding: 1.5vmin 2vmin;
      border-radius: 1vmin;
      box-shadow: 0 0.5vmin 1.5vmin rgba(0, 0, 0, 0.2);
      z-index: 10;
      font-size: 2.5vmin;
    }
    #infoPanel p {
      margin: 1vmin 0;
    }
    #robotSelector {
      position: absolute;
      top: 2vmin;
      right: 2vmin;
      z-index: 10;
      text-align: right;
      font-size: 2.5vmin;
    }
    #toggleSelector {
      background: #007bff;
      color: white;
      border: none;
      padding: 1.5vmin 2vmin;
      border-radius: 1vmin;
      cursor: pointer;
    }
    #selectorOptions {
      display: none;
      margin-top: 1vmin;
      background: rgba(255, 255, 255, 0.9);
      padding: 2vmin;
      border-radius: 1vmin;
      box-shadow: 0 0.5vmin 1.5vmin rgba(0, 0, 0, 0.2);
      text-align: left;
    }
    #selectorOptions label {
      display: block;
      margin-bottom: 1.5vmin;
      cursor: pointer;
    }
    #cameraFeed {      
      position: absolute;
      top: 15vh;
      left: 20vw;
      width: 50vw;
      height: 70vh;
      border: 0.5vmin dashed #666;
      border-radius: 1vmin;
      background: #000;
      z-index: 5;
      transform: rotate(180deg);
    }
    #pos_map{
      position: absolute;
      top: 15vh;
      left: 72vw;
      width: 21vw;
      height: 38vh;
      border: 0.5vmin dashed #666;
      border-radius: 1vmin;
      background: #000;
      z-index: 5;
    }
    #point_map{
      position: absolute;
      top: 57vh;
      left: 72vw;
      width: 21vw;
      height: 28vh;
      border: 0.5vmin dashed #666;
      border-radius: 1vmin;
      background: #000;
      z-index: 5;
    }
    #cameraFeed video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    #controls {
      position: absolute;
      bottom: 5vmin;
      left: 5vmin;
      display: grid;
      grid-template-areas: ". up ." "left . right" ". down .";
      grid-template-columns: 1fr 1fr 1fr;
      grid-template-rows: 1fr 1fr 1fr;
      gap: 1vmin;
      z-index: 10;
    }
    .ctrl-btn {
      width: 8vmin;
      height: 8vmin;
      border-radius: 50%;
      background: #007bff;
      color: white;
      font-size: 4vmin;
      border: none;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      touch-action: none;
      cursor: pointer;
    }
    #btnForward { grid-area: up; }
    #btnBackward { grid-area: down; }
    #btnLeft { grid-area: left; }
    #btnRight { grid-area: right; }
    .rotate-90, .rotate-270 { display: inline-block; }
    .rotate-90 { transform: rotate(90deg); }
    .rotate-270 { transform: rotate(270deg); }
  </style>
</head>
<body>
  <div id="gameArea">
    <div id="infoPanel">
      <p>Battery: <span id="battery">–</span></p>
      <p>PID output: <span id="pidP">–</span></p>
      <p>Depth measured: <span id="depthValue">–</span></p>
    </div>

    <div id="robotSelector">
      <button id="toggleSelector">Robot 1 (online) ▾</button>
      <div id="selectorOptions">
        <label><input type="radio" name="robot" value="1" checked> Robot 1 (<span id="status1">online</span>)</label>
        <label><input type="radio" name="robot" value="2"> Robot 2 (<span id="status2">offline</span>)</label>
      </div>
    </div>

    <div id="cameraFeed">
      <video id="videoStream" autoplay playsinline></video>
      <canvas id="cameraOverlay"></canvas>
    </div>

    <div id="pos_map">
      <!-- Canvas for 2D map will be created here -->
    </div>

    <div id="point_map">
      <canvas id="pointCloud"></canvas>
    </div>

    <div id="controls">
      <button class="ctrl-btn" id="btnForward">▲</button>
      <button class="ctrl-btn" id="btnLeft"><span class="rotate-90">↶</span></button>
      <button class="ctrl-btn" id="btnRight"><span class="rotate-270">↷</span></button>
      <button class="ctrl-btn" id="btnBackward">▼</button>
    </div>
    
    <div id="coordinateDisplay"></div>
    <button id="btnPhoto" class="ctrl-btn" style="position:absolute;bottom:5vmin;right:5vmin;">📸</button>
  </div>

    <script>
    let sensorData = {}; 
    let MapArray = [2.1, 0, 0, 0];

    const SIGNALING_BASE = `http://${window.location.hostname}:8000`;
    const LOG_API = "http://35.177.215.40:8001";

    let pc = null;
    let dataChannel = null;
    const frameMap = new Map();
    let seenFrames = 0;
    const MAX_SAMPLES = 15;
    let clockOffset = 0;

    // 1) Define sendControl() globally
    function sendControl(direction) {
      if (dataChannel && dataChannel.readyState === "open") {
        const msg = {
          robotId:   document.querySelector('input[name="robot"]:checked').value,
          action:    "move",
          direction: direction,
          timestamp: new Date().toISOString()
        };
        dataChannel.send(JSON.stringify(msg));
        

        if (direction && direction.toLowerCase() !== "stop") {
          try {
            const battStr = document.getElementById("battery")?.textContent || "0";
            const battery = parseInt(battStr.replace(/[^0-9]/g, ''), 10) || 0;
            fetch(LOG_API + "/log", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                battery: battery,
                mode: "MANUAL",
                action: direction.toUpperCase()
              })
            });
          } catch (err) {
            console.warn("Auto‑log failed:", err);
          }
        }
        console.log("Sent control →", msg);
      } else {
        console.warn("Cannot sendControl; dataChannel not open");
      }
    }

    // 2) Set up WebRTC / DataChannel
    async function startWebRTC() {
      pc = new RTCPeerConnection({
        iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
      });

      pc.addTransceiver("video", { direction: "recvonly" });

      dataChannel = pc.createDataChannel("control", { ordered: true });
      dataChannel.onopen = () => {
        console.log(" DataChannel is now OPEN");
        // Mark selected robot as online
        const sel = document.querySelector('input[name="robot"]:checked');
        sel.parentNode.querySelector('span').textContent = "online";
        const t0 = Date.now();
        dataChannel.send(JSON.stringify({
          type:      "sync_req",
          ts_client: t0
        }));
        setInterval(() => {
          const t0 = Date.now();
          dataChannel.send(JSON.stringify({ type: "ping", ts: t0 }));
        }, 1000);
      };
      dataChannel.onmessage = (evt) => {
        const msg = JSON.parse(evt.data);
        if (msg.type === "pong") {
          const rtt = Date.now() - msg.ts;
          console.log(`Control RTT: ${rtt} ms`);
          return;
        }
          // battery & PID telemetry
        if (msg.battery !== undefined && msg.pid !== undefined) {
          document.getElementById("battery").textContent = msg.battery.toFixed(1) + "%";
          document.getElementById("pidP").textContent    = msg.pid.toFixed(2);
          if (msg.depth !== undefined) {
            document.getElementById("depthValue").textContent = msg.depth.toFixed(2) + " m";
          }
          return;
        }
        if (msg.type === "sync_res") {
          // how far Pi’s clock is ahead of browser’s clock
          clockOffset = msg.ts_client - msg.ts_server;
          console.log("Clock offset (ms):", clockOffset.toFixed(1));
          return;
        }
        if (msg.frame_id) {
          frameMap.set(msg.frame_id, msg.capture_ts);
          return;
        }
        console.log("Telemetry from Pi:", evt.data);
        try {
          const telemetry = JSON.parse(evt.data);
          const d1 = telemetry.depth.toFixed(3)/1000;
          const px1 = telemetry.pos_x.toFixed(3);
          const py1 = telemetry.pos_y.toFixed(3);
          const a1 = telemetry.yaw.toFixed(2);

          MapArray = [d1, px1, py1, a1];

          document.getElementById("battery").textContent      = telemetry.battery + "%";
          document.getElementById("pidP").textContent         = telemetry.pidP;
          document.getElementById("pidI").textContent         = telemetry.pidI;
          document.getElementById("pidD").textContent         = telemetry.pidD;
          document.getElementById("depthValue2").textContent  = d1;
          document.getElementById("pos_x").textContent        = px1;
          document.getElementById("pos_y").textContent        = py1;
          document.getElementById("yaw").textContent          = a1;
          document.getElementById("depthTs").textContent      = new Date(telemetry.depthTs).toLocaleTimeString();
        } catch (e) {
          console.warn("Invalid telemetry JSON:", e);
        }
      };
      dataChannel.onclose = () => {
        console.log(" DataChannel closed");
        const sel = document.querySelector('input[name="robot"]:checked');
        sel.parentNode.querySelector('span').textContent = "offline";
      };

      const video = document.getElementById("videoStream");
      pc.ontrack = ev => {
        if (!video.srcObject) {
          video.srcObject = ev.streams[0];
          // start exactly one measurement loop
          video.requestVideoFrameCallback(measureLatency);
        }
      };

      function measureLatency(now, metadata) {
        seenFrames++;
        const captureTs = frameMap.get(seenFrames);
        if (captureTs !== undefined) {
        const arrivalTs = Date.now() - clockOffset;
          console.log(
            `Frame ${seenFrames} latency: ${ (arrivalTs - captureTs).toFixed(1) } ms`
          );
        }
        if (seenFrames < MAX_SAMPLES) {
          video.requestVideoFrameCallback(measureLatency);
        }
      }

      // 2a) Create an SDP offer and wait for ICE gathering
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);

      await new Promise(resolve => {
        if (pc.iceGatheringState === "complete") {
          resolve();
        } else {
          pc.onicegatheringstatechange = () => {
            if (pc.iceGatheringState === "complete") {
              pc.onicegatheringstatechange = null;
              resolve();
            }
          };
        }
      });

      // 2b) POST the complete SDP to /offer on the Pi
      let resp;
      try {
        resp = await fetch(`${SIGNALING_BASE}/offer`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            peer_id: "browser1",
            type:    pc.localDescription.type,
            sdp:     pc.localDescription.sdp
          })
        });
      } catch (networkError) {
        console.error("Network error when calling /offer:", networkError);
        return;
      }

      if (!resp.ok) {
        const text = await resp.text();
        console.error("Offer failed", resp.status, text);
        return;
      }

      let answer;
      try {
        answer = await resp.json();
      } catch (jsonError) {
        console.error("Failed to parse JSON from /offer:", jsonError);
        return;
      }

      await pc.setRemoteDescription(new RTCSessionDescription(answer));
      console.log("WebRTC connection established");
    }
    
    let currentDataIndex = 0;
    const mapCanvas = document.createElement('canvas');
    const mapCtx = mapCanvas.getContext('2d');
    const posMap = document.getElementById('pos_map');
    posMap.appendChild(mapCanvas);

    // 5m x 5m 地图，250x250 像素 (每个像素 0.02m)
    const mapSize = 2.5; // 5 meters
    const mapPixels = 250; // 250 pixels
    const pixelSize = mapSize / mapPixels; // 0.02m per pixel

    // 固定显示内容为 2m x 2m (实际显示大小由pos_map决定)
    const displayContentSize = 1.7; // 2 meters

    function setupCanvas() {
      // 使canvas与pos_map大小一致
      mapCanvas.width = posMap.clientWidth;
      mapCanvas.height = posMap.clientHeight;
    }

    const mapState = {
      exploredPaths: [],
      detectedSurfaces: [],
      robotPath: [],
      robotPosition: { x: mapSize/2, y: mapSize/2 }, // 初始在中心 (2.5m, 2.5m)
      robotAngle: 0,
      robotRadius: 0.08 // 8cm radius
    };

    // 创建地图数据数组 (250x250)
    let mapData = new Array(mapPixels);
    for (let i = 0; i < mapPixels; i++) {
      mapData[i] = new Array(mapPixels).fill(0); // 0表示未探索
    }

    function initMap() {
      setupCanvas();
      drawMap();
      mapCanvas.addEventListener('click', handleMapClick);
      window.addEventListener('resize', () => {
        setupCanvas();
        drawMap();
      });
    }

function getLinePixels(x0, y0, x1, y1) {
    const pixels = [];
    const dx = Math.abs(x1 - x0);
    const dy = Math.abs(y1 - y0);
    const sx = (x0 < x1) ? 1 : -1;
    const sy = (y0 < y1) ? 1 : -1;
    let err = dx - dy;

    const maxLength = Math.max(dx, dy) * 2; // Reasonable upper bound
    
    while (pixels.length < maxLength) { // Add a safety limit
        pixels.push({ x: x0, y: y0 });
        
        if (x0 === x1 && y0 === y1) break;
        
        const e2 = 2 * err;
        if (e2 > -dy) {
            err -= dy;
            x0 += sx;
        }
        if (e2 < dx) {
            err += dx;
            y0 += sy;
        }
    }
    
    return pixels;
}

    function drawMap() {
      const width = mapCanvas.width;
      const height = mapCanvas.height;
      
      // 计算比例因子 (将2m内容适应到当前canvas大小)
      const scale = Math.min(width, height) / displayContentSize;
      
      // 计算显示窗口的边界 (以机器人位置为中心)
      const minX = Math.max(0, mapState.robotPosition.x - displayContentSize/2);
      const maxX = Math.min(mapSize, mapState.robotPosition.x + displayContentSize/2);
      const minY = Math.max(0, mapState.robotPosition.y - displayContentSize/2);
      const maxY = Math.min(mapSize, mapState.robotPosition.y + displayContentSize/2);
      
      // 清除画布
      mapCtx.fillStyle = '#d3d3d3';
      mapCtx.fillRect(0, 0, width, height);
      
      // 计算偏移量 (使机器人始终在中心)
      const offsetX = width/2 - mapState.robotPosition.x * scale;
      const offsetY = height/2 - mapState.robotPosition.y * scale;
      
      // 绘制探索区域 (从mapData读取)
      for (let y = 0; y < mapPixels; y++) {
        for (let x = 0; x < mapPixels; x++) {
          const realX = x * pixelSize;
          const realY = y * pixelSize;
          
          // 只绘制在显示范围内的像素
          if (realX >= minX && realX <= maxX && realY >= minY && realY <= maxY) {
            const screenX = realX * scale + offsetX;
            const screenY = realY * scale + offsetY;
            const pixelSizeScaled = pixelSize * scale;
            
            if (mapData[y][x] === 1) { // 探索区域
              mapCtx.fillStyle = 'rgba(127, 255, 212, 0.4)';
              mapCtx.fillRect(screenX, screenY, pixelSizeScaled, pixelSizeScaled);
            } else if (mapData[y][x] === 2) { // 障碍物表面
              mapCtx.fillStyle = '#0000ff';
              mapCtx.fillRect(screenX, screenY, pixelSizeScaled, pixelSizeScaled);
            }
          }
        }
      }
      
      // 绘制机器人路径
      mapCtx.strokeStyle = 'rgba(127, 255, 212, 0.7)';
      mapCtx.lineWidth = 2;
      mapCtx.beginPath();
      mapState.robotPath.forEach((point, index) => {
        const x = point.x * scale + offsetX;
        const y = point.y * scale + offsetY;
        if (index === 0) {
          mapCtx.moveTo(x, y);
        } else {
          mapCtx.lineTo(x, y);
        }
      });
      mapCtx.stroke();
      
      // 绘制机器人 (始终在中心)
      const robotX = width/2;
      const robotY = height/2;
      const robotRadiusScaled = mapState.robotRadius*0.3 * scale;
      mapCtx.fillStyle = '#ff0000';
      mapCtx.beginPath();
      mapCtx.arc(robotX, robotY, robotRadiusScaled, 0, Math.PI * 2);
      mapCtx.fill();
    }

    function simulateRobot() {
      if (sensorData.length === 0) {
        return;
      }
      const data = sensorData[currentDataIndex];
      if (!data || data.depth === undefined) {
        return;
      }
      const depthValue = document.getElementById('depthValue');
      //console.log(data);
      depthValue.textContent = `${data.depth.toFixed(2)}m`;
      mapState.robotAngle = data.orient_y.toFixed(2);

      mapState.robotPosition.x += data.d_pos_x;
      mapState.robotPosition.y += data.d_pos_y;
      
      mapState.robotPosition.x = Math.max(mapState.robotRadius, Math.min(mapSize - mapState.robotRadius, mapState.robotPosition.x));
      mapState.robotPosition.y = Math.max(mapState.robotRadius, Math.min(mapSize - mapState.robotRadius, mapState.robotPosition.y));
      
      mapState.robotPath.push({
        x: mapState.robotPosition.x,
        y: mapState.robotPosition.y
      });
      
      if (mapState.robotPath.length > 300) {
        mapState.robotPath.shift();
      }
      
      // 更新探索区域 (标记为1)
      const robotX = Math.floor(mapState.robotPosition.x / pixelSize);
      const robotY = Math.floor(mapState.robotPosition.y / pixelSize);
      for (let dy = -5; dy <= 5; dy++) {
        for (let dx = -5; dx <= 5; dx++) {
          const x = robotX + dx;
          const y = robotY + dy;
          if (x >= 0 && x < mapPixels && y >= 0 && y < mapPixels) {
            mapData[y][x] = 1;
          }
        }
      }
      
      // 更新障碍物表面 (标记为2)
      const rayLength = MapArray[0]; // 当前深度值
      const angleRad = mapState.robotAngle * Math.PI / 180;
      const dirX = Math.sin(angleRad);
      const dirY = -Math.cos(angleRad);
      
      const startX = Math.floor(mapState.robotPosition.x / pixelSize);
      const startY = Math.floor(mapState.robotPosition.y / pixelSize);
      const endX = Math.floor((mapState.robotPosition.x + dirX * rayLength) / pixelSize);
      const endY = Math.floor((mapState.robotPosition.y + dirY * rayLength) / pixelSize);
      
      const rayPixels = getLinePixels(startX, startY, endX, endY);
      
      for (let i = 0; i < rayPixels.length - 1; i++) {
        const px = rayPixels[i].x;
        const py = rayPixels[i].y;
        
        if (px >= 0 && px < mapPixels && py >= 0 && py < mapPixels) {
          // 只清除障碍物标记，保留探索状态
          if (mapData[py][px] === 2) {
            mapData[py][px] = 1;
          }
        }
      }

      // 标记新的障碍物表面（仅射线终点）
      if (endX >= 0 && endX < mapPixels && endY >= 0 && endY < mapPixels) {
        // 只更新障碍物位置（覆盖之前的标记）
        mapData[endY][endX] = 2;
      }
      
      // 重绘地图
      drawMap();
      
      // 更新数据索引
      currentDataIndex = (currentDataIndex + 1) % sensorData.length;
    }

    function handleMapClick(event) {
      const rect = mapCanvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      
      const width = mapCanvas.width;
      const height = mapCanvas.height;
      
      // 计算比例因子
      const scale = Math.min(width, height) / displayContentSize;
      
      // 计算偏移量
      const offsetX = width/2 - mapState.robotPosition.x * scale;
      const offsetY = height/2 - mapState.robotPosition.y * scale;
      
      // 计算实际坐标
      const realX = (x - offsetX) / scale;
      const realY = (y - offsetY) / scale;
      
      const mmX = Math.round(realX * 1000);
      const mmY = Math.round(realY * 1000);

      const display = document.getElementById('coordinateDisplay');
      display.textContent = `Clicked at: X=${mmX}mm, Y=${mmY}mm`;
      display.style.display = 'block';
      
      setTimeout(() => {display.style.display = 'none';}, 3000);
      
      mapCtx.fillStyle = '#ff9900';
      mapCtx.beginPath();
      mapCtx.arc(x, y, 5, 0, Math.PI * 2);
      mapCtx.fill();
    }
        
    // 初始化
    window.addEventListener('load', () => {
      startWebRTC().catch(e => console.error("startWebRTC() threw:", e));
      initMap();
      
      // 开始模拟
      setInterval(simulateRobot, 50); // 20Hz更新
    });

    // 3) Attach keydown/keyup listeners
    console.log("Attaching keydown/keyup listeners");
    document.addEventListener('keydown', e => {
      switch (e.key.toLowerCase()) {
        case 'w': sendControl("forward");  break;
        case 's': sendControl("backward"); break;
        case 'a': sendControl("left");     break;
        case 'd': sendControl("right");    break;
      }
    });
    document.addEventListener('keyup', e => {
      switch (e.key.toLowerCase()) {
        case 'w':
        case 's':
        case 'a':
        case 'd':
          sendControl("stop");
          break;
      }
    });

    // 4) Attach on-screen button listeners 
    ["Forward","Backward","Left","Right"].forEach(dir => {
      const btn  = document.getElementById("btn" + dir);
      const move = dir.toLowerCase();

      let intervalId;

      btn.addEventListener("pointerdown", e => {
        btn.setPointerCapture(e.pointerId);
        // send immediately
        sendControl(move);
        // then every 100 ms while held
        intervalId = setInterval(() => sendControl(move), 100);
      });

      ["pointerup","pointercancel"].forEach(evt => {
        btn.addEventListener(evt, e => {
          clearInterval(intervalId);
          sendControl("stop");
          btn.releasePointerCapture(e.pointerId);
        });
      });
    });

    // 5) Robot selector dropdown logic
    const toggleBtn = document.getElementById('toggleSelector');
    const opts      = document.getElementById('selectorOptions');
    function updateToggle() {
      const sel = document.querySelector('input[name="robot"]:checked');
      toggleBtn.textContent = sel.parentNode.textContent.trim() + ' ▾';
    }
    toggleBtn.addEventListener('click', () => {
      opts.style.display = opts.style.display === 'block' ? 'none' : 'block';
    });
    document.querySelectorAll('input[name="robot"]').forEach(r => {
      r.addEventListener('change', () => updateToggle());
    });
    updateToggle();
    
    //  Take photo and POST to /image
async function takePhoto() {
  const video = document.getElementById("videoStream");
  if (!video || video.readyState < 2) {
    alert("Camera not ready!");
    return;
  }
  const canvas = document.createElement("canvas");
  canvas.width  = video.videoWidth  || 640;
  canvas.height = video.videoHeight || 480;
  canvas.getContext("2d").drawImage(video, 0, 0, canvas.width, canvas.height);
  const base64 = canvas.toDataURL("image/png").split(",")[1];
  const payload = {
    timestamp: Math.floor(Date.now() / 1000),
    image: base64
  };
  try {
    const r = await fetch(LOG_API + "/image", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });
    if (r.status === 204) {
      alert("Image uploaded!");
    } else {
      const txt = await r.text();
      alert("Upload failed:" + txt);
    }
  } catch (err) {
    alert("Error: " + err.message);
  }
}
document.getElementById("btnPhoto")?.addEventListener("click", takePhoto);

  </script>
</body>
</html>